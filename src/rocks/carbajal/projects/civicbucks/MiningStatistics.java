/**
 * MIT License
 *
 * Copyright (c) 2017 Pablo Alejandro Carbajal Siller
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package rocks.carbajal.projects.civicbucks;

import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Instances of this class represent statistics generated by the
 * {@link MiningExecutor}.
 *
 * @author Pablo A. Carbajal
 *
 */
public class MiningStatistics {

	/**
	 * Statistical data unit for holding statistics of a single task.
	 *
	 * @author Pablo A. Carbajal
	 *
	 */
	private class StatisticalData {

		/**
		 * The start time of a single task.
		 */
		final private long mStartTime;

		/**
		 * The end time of a single task.
		 */
		private long mEndTime = 0;

		/**
		 * Creates a new instance of a statistic data unit for a single task.
		 *
		 * @param taskName
		 *            Name of the task that generated the statistic data.
		 * @param startTimeMillis
		 *            Start time of the task in millis.
		 */
		StatisticalData(final String taskName, final long startTimeMillis) {
			mStartTime = startTimeMillis;
		}

		/**
		 * Returns the duration of the a task.
		 */
		long getDuration() {
			// TODO Assumes all tasks are done, need to check for incomplete
			// cases.
			return mEndTime - mStartTime;
		}

		/**
		 * @param millis
		 */
		void setEndTime(final long millis) {
			mEndTime = millis;
		}
	}

	/**
	 * This field holds a map of statistics for each task, where the key is the
	 * task name and the value is the task's statistical data.
	 */
	// The implementation is ConcurrentHashMap for thread-safe operations
	final Map<String, StatisticalData> mStatisticsCollector = new ConcurrentHashMap<>();

	/**
	 * Calling this method marks the specified task as completed at the time of
	 * the call.
	 *
	 * @param taskName
	 *            Name of the task to mark as completed.
	 */
	public void end(final String taskName) {
		final StatisticalData taskData = mStatisticsCollector.get(taskName);
		taskData.setEndTime(System.currentTimeMillis());
	}

	/**
	 * Returns the max time taken by a computation (in millis).
	 */
	public long getMaxTime() {
		/*
		 * The max time is calculated by iterating over the entire statistical
		 * collection and keeping track of the highest duration value.
		 */
		long maxTime = 0;
		final Iterator<Entry<String, StatisticalData>> iterator = mStatisticsCollector.entrySet().iterator();
		while (iterator.hasNext()) {
			final Entry<String, StatisticalData> pair = iterator.next();
			final StatisticalData data = pair.getValue();

			// if we found a higher value, keep it
			if (maxTime < data.getDuration()) {
				maxTime = data.getDuration();
			}
		}

		return maxTime;
	}

	/**
	 * Returns the mean computation time of all computations in millis.
	 */
	public long getMeanTime() {
		/*
		 * Find the mean by adding up the duration from the entire statistical
		 * collection and, at the end, divide it by the total number of
		 * computations.
		 */
		long cumulativeTime = 0;
		final Iterator<Entry<String, StatisticalData>> iterator = mStatisticsCollector.entrySet().iterator();
		while (iterator.hasNext()) {
			final Entry<String, StatisticalData> pair = iterator.next();
			final StatisticalData data = pair.getValue();
			cumulativeTime += data.getDuration();
		}

		// TODO assumes all tasks have completed... should ignore incomplete
		// tasks
		return cumulativeTime / mStatisticsCollector.size();
	}

	/**
	 * Calling this method marks the start of the specified task.
	 *
	 * @param taskName
	 *            Name of the task to mark as completed.
	 */
	public void start(final String taskName) {
		final StatisticalData taskData = new StatisticalData(taskName, System.currentTimeMillis());
		mStatisticsCollector.put(taskName, taskData);
	}
}